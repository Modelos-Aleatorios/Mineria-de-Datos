---
title: "Proyecto Tópicos I"
author: "Alexander A. Ramírez M. (alexanderramirez.me) y Daysi Febles (daysilorenafeblesr@gmail.com)"
date: "30/4/2017"
output:
  pdf_document: 
    toc: yes
    toc_depth: 5
    fig_width: 8
  html_document: 
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#install.packages("corrplot")
library(readr)
library(knitr)
library(corrplot)
library(RColorBrewer)
library(rgl)
library(plot3D)
library(scatterplot3d)
library(latex2exp)
```

## Conclusiones

- Hay que enfocarse en las campañas óptimas, es decir, las que generan menor costo por click, mayor tasa de cornversión y menor costo por ventas. Estas campañas son "", "" y "".
- Se recomienda repetir las campañas "" ya que tienen el potencial de generar ventas dado el costo por click y la tasa de conversión.
- `Bolivian Alpaca English` es la campaña con menor `Costc`. Esta campaña se debe repetir para aprovechar la eficiencia en Costo que genera la campaña.
- Hay relaciones de dependenci

- Contamos con poco tiempo para realizar estudios más profundos, sin embargo, hemos hecho una lista de estudios adicionales que pueden contribuir a modelar y optimizar las campañas.
- El trabajo nos permitió aumentar el número de ventas, sin embargo no sabemos cual es el ingreso por cada venta y tampoco su utilidad (ganancia neta por producto vendido). Es por ello que no estamos optimizando los ingresos o la utilidad de la empresa en las ventas. Sólo estamos intentando optimizar, es decir, maximizando las unidades vendidas al menor costo posible.

## Hallazgos

- El $x\%$ de los datos tiene $0$ impresiones, $y\%$ $0$ `Clicks` y $z\%$ no tiene Ventas.
- Son X campañas en total de las cuales, Y tienen impresiones, Z tienen Clicks y W tienen Ventas.
- La campaña más exitosa es 
- La campaña con mejor relación de costo beneficio es 
- 

## Trabajo por hacer

- Revisión de las campañas que no generan impresiones. Es posible una relación entre el `MaxCPC` y `Qscore` y la falta de impresiones. Es decir, no se generan impresiones ya que el anunciante no paga suficiente o el contenido no es relevante.
- Revisión de las campañas que no generan `Clicks`. Es posible una relación entre la posisión y los `Clicks`. Es decir, el anuncio no aparece en las primeras posiciones para que aumente la probabilidad de que el usuario le haga `Click` al anuncio.

## ¿Cuál es el problema que queremos resolver?

Contamos con datos sobre campañas de publicidad en internet. Estos datos provienen de algún motor de publicidad en internet mediante palabras claves como [**Google Adwords**](https://www.google.co.ve/adwords/?channel=ha&sourceid=awo&subid=rola-es-ha-aw-bhrh&gclid=Cj0KEQjwuZvIBRD-8Z6B2M2Sy68BEiQAtjYS3DK1t7RTmcIKbHEq57eBanGEAdgokPpx_IA0KL59WVEaAuRl8P8HAQ). 

Estos motores parten de la búsqueda, mediante palabras claves, que realizan los usuarios en un buscador como Google y este genera los resultados que más relevantes de acuerdo a diversos criterios. El éxito de un buscador consiste en generar resultados relevantes para cada búsqueda y para ello se basan en el contexto (información de distintas fuentes sobre el que busca, donde lo realiza, el horario, lo que busca específicamente, diversas opciones, etc) y por otra parte el motor de búsqueda mantiene los datos sobre el contenido en internet clasificado y calificado. El motor de búsqueda refina contínuamente y asocia cual contenido es relevante y de calidad y lo asocia a los términos o palabras clave más representativos del contenido.

![](img/process.png)

La publicidad en Internet, como muchos negocios masivos exitosos, se basa en unir la oferta con la demanda, permitiendo a los usuarios conseguir información relevante por una parte y por la otra permitiendo a los anunciantes ofrecer información relevante que termine generando algún beneficio para el anunciante.

El proceso que siguen estos sistemas es el siguiente:

- El anunciante define las palabras claves que caracterizan el contenido de su sitio web.

![](img/match.png)

- A partir de estas palabras y la combinación de estas palabras se crean campañas de manera que cada vez que un usuario busca algún contenido relacionado con dichas palabras el sitio web del anunciante aparezca en la mejor posición posible.
- El anunciante define el costo (máximo) que está dispuesto a pagar por un click, esto se denomina CPC (Costo por Click). A partir de varias métricas como el Qscore, que mide la calidad del contenido en base a las palabras claves y la experiencia de los usuarios en el sitio web del anunciante. El sistema busca la mejor combinación entre CPC y Qscore (entre otras) para generar una lista de resultados ordenada en base al que está dispuesto a pagar más y tiene mejor contenido. De esta manera se genera el contenido más relevante, con la mejor experiencia de usuario (un usuario que consigue lo que busca) y al mismo tiempo le genera el mejor negocio al buscador.

![](img/cost.png)

Se desea minimizar el costo y maximizar las ventas. Es decir, se desea que el `Costc` sea mínimo para obtener la mayor cantidad de ventas al menor costo posible.

## Limpieza de datos

Lo primero que hemos hecho es tomar los datos provisto en Excel y hemos convertido los datos a números y las variables como porcentajes también se han convertido a números.

Las actividades realizadas paso a paso son las siguientes:

- `CTR`: Se dividió el número entre $100$ para convertirlo a un número.

- `Convrate`: Se dividió entre $10000$ para convertirla a un número.

Después de realizar la conversión en Excel se cargaron los datos en **R** mediante el comando `read_delim`, donde especificamos el separador de los campos como ";" y el separador de miles "," y símbolo decimal ".".

A continuación podemos ver el comando ejecutado para importar los datos.
```{r, echo=TRUE}
data <- read_delim("../data/ROW.csv", 
    ";", escape_double = FALSE, locale = locale(decimal_mark = ",", 
    grouping_mark = "."), trim_ws = TRUE)
```

Como la variable `Allconv` es una variable redundante, ya que es igual a la variable Ventas, esta se eliminó. Adicionalmente vamos a renombrar las variables.

```{r}
#Eliminada la variable Allconv
data<-data[,-13]
#Renombrar las variables
colnames(data)<-c("Adgroup","MaxCPC","Clicks","Impr",
                    "CTR","AvgCPC","Costo","AvgPos","Qscore",
                    "Ventas","Costc","Convr")
```

A partir de ahora los datos con los que vamos a trabajar van a estar en la variable `data`.

Vamos a ver las primeras 6 filas.
```{r}
head(data, n=6)
```

Hay un detalle del cual nos hemos percatado en relación a las campañas y este es que hay muchos registros de campañas sin ninguna Impresión. 
```{r, warning=FALSE}
data_original<-data
data<-data[data$Impr!=0,]
#Datos con impresiones en data_w_impr
data_w_impr<-data
#Datos con Clicks en data_w_clicks
data_w_clicks<-data[data$Clicks!=0,]
#Datos con Ventas en data_w_sales
data_w_sales<-data_w_clicks[data_w_clicks$Ventas!=0,]
```

Vamos a mantener los datos originales en la variable `data_original`.

```{r, echo=FALSE}
rows_data_original<-dim(data_original[,])[1]
cols_data_original<-dim(data_original[,])[2]
rows_data<-dim(data[,])[1]
cols_data<-dim(data[,])[2]
```

Los datos provistos están conformados por `r cols_data` variables y datos de `r rows_data_original` campañas. Sin embargo, hay `r rows_data` campañas con al menos una impresión. Si no hay impresiones la campaña no arroja ningún tipo de resultado, ya que no hay `Clicks` ni `Ventas` ni `Costo`. Es por ello que vamos a trabajar principalmente con campañas que al menos generan impresiones, es decir, aparecen en pantalla y los usuarios que están buscando información pueden hacer Click o no si les parece relevante.

En relación a esta decisión tenemos varias interrogantes:

- ¿Qué dependencias hay entre las variables?
- ¿Hay alguna relación entre el `MaxCPC`, `QScore` y el número de impresiones?
- ¿Hay alguna relación entre la campaña en sí mismo, las palabras clave, y las impresiones?
- ¿Qué importancia tienen las impresiones en el modelo?
- ¿Cuales campañas son más eficientes si se minimiza el costo y si se maximizan las ventas?

En la medida que avanzamos vamos a intentar dar luces sobre cada una de estas interrogantes y con especial énfasis las dos últimas.

## Variables[^2] del modelo

A continución la lista de variables y su descripción breve:

| Nombre          | Descripción                                                                 |
|-----------------|-----------------------------------------------------------------------------|
| Adgroup         | Grupos de campañas publicitarias                                            |
| MaxCPC          | Lo que el dueño de la campaña está dispuesto a pagar por publicidad. (Bid)  |
| Clicks          | Número de veces que un usuario de internet hace click sobre la publicidad.  |
| Impr            | Total de veces que la publicidad fué impresa en internet.  |
| CTR             | Cociente entre Clicks e Impressions   |
| AvgCPC          | Lo que termina pagando por la publicación de la publicidad.  |
| Costo           | Gasto de publicidad. |
| AvgPos          | Posición promedio en la que sale el anuncio publicitario. |
| Qscore[^1]      | Puntaje de calidad de la publicidad.  |
| Ventas          | Total de ventas. |
| Costc           | Cociente entre Costo y Ventas.  |
| Convr           | Cociente entre Ventas y Clicks.  |

Vamos a detallar un poco mejor la terminología para entender qué función cumple cada variable.

- **Adgroup**: contiene una o más anuncios que están dirigidos mediante un conjunto de palabras claves (keywords). Tenemos campañas con nombre "Bear English" y "Poncho English". Estas son las palabras claves. El anunciante define si precio por click (MaxCPC) para que se utilice en el momento que un anuncio aparezca y se active.
- **MaxCPC**: Si alguien hace click en un anuncio, ese click no costará más que el **MaxCPC** definido por el anunciante. El monto que el anunciante pagó es Costo. Un **MaxCPC** mayor significa generalmente que el anuncio puede aparecer en una mejor posición.
- **AvgCPC**: Es el promedio que se paga por cada click. Se calcula dividiendo el costo total entre el número de Clicks.
- **Impr**: Es que tan frecuente el anuncio aparece. Se cuenta una impresión cada vez que se muestra el anuncio como resultado de una búsqueda.
- **CTR**: El cociente que muestra que tan frecuentemente las personas que ven tu anuncio terminan haciento click. **CTR** se puede utilizar para medir que tan efectiva es una campaña. Un **CTR** alto es un buen indicador de que los usuarios encuentran los anuncios útiles y relevantes. El **CTR** también contribuye al CTR Esperado (un componente de Quality Score), que afecta el costo y la posición.
- **AvgPos**: Es un estadístico que describe en qué rango se encuentra el anuncio frente a otros. Este rango determina el orden en el cual aparecen los anuncios en la página. El mayor valor es $1$. El promedio un valor entre $1$ y $8$ significa que el anuncio aparece en la primera página de $9$ a $16$ generalmente aparece en la segunda página.
- **QScore**: Es una estimación de la calidad del anuncio, las palabras claves y la página. Un **QScore** mayor puede generar menores precios y mejores posiciones. La escala es del $1$ al $10$ y sus componentes son el CTR esperado, relevancia del anuncio y experiencia de usuario en la página resultante. Mientras más relevante sean los anuncios y las páginas del anunciante para el usuario, es más probable que obtengan mayores **Quality Scores**.

## `Costc`

La variable que tenemos que minimizar es `Costoc`, veamos un gráfico de esta función con los datos cargados:

```{r}
x<-data$Costo
y<-data$Ventas
z<-data$Costc

df<-data.frame(x,y,z)
df<-df[order(df$x),]

scatterplot3d(df$x,df$y,df$z,pch=16, main="3D Scatterplot",xlab = "Costo",
              ylab = "Ventas",zlab = "Costoc",angle = 110, type="p")

scatter3D(df$x,df$y,df$z, phi = 20, theta = 15,pch=16, col = "black",type="p",xlab = "Costo",
          ylab = "Ventas",zlab = "Costoc")

```

## Definición de algunas variables

Hemos visto que varias de las variables son el resultado del cociente entre otras dos variables. En particular `CTR`, `AvgCPC`, `Convrate` y `Convcost`.

$$
\begin{array}{ll}
\vspace{3mm} CTR&=\displaystyle\frac{Click}{Impression}\\ 
\vspace{3mm} AvgCPC&=\displaystyle\frac{Costo}{Clicks}\\
\vspace{3mm} Convr&=\displaystyle\frac{Ventas}{Clicks}\\
Costc&=\displaystyle\frac{Costo}{Ventas}
\end{array}
$$


## Estadística descriptiva

TODO: Eliminar outliers

### Campañas

Primero vamos a obtener la lista de las campañas que se han realizado.

Para ello creamos un vector con todas las campañas y eliminamos los elementos repetidos.
```{r}
varsv<-unique(as.vector(data$Adgroup))
varsvo<-unique(as.vector(data_original$Adgroup))
```

Podemos ver que son `r length(varsvo)` campañas. Estas son: `r varsvo`. 

Sin embargo, hay `r length(varsv)` campañas con al menos una impresión. 

Las campañas con al menos una impresión son `r varsv`.

Ahora podemos ver las campañas y cuantas de ellas produjeron impresiones y cuantas de ellas no.

```{r, echo=FALSE}
datacamp<-data_original
for(i in 1:(length(varsvo))) {
  datacamp$Adgroup[datacamp$Adgroup==varsvo[i]]<-i
}
datacamp$Adgroup<-as.numeric(datacamp$Adgroup)

do_df<-as.data.frame(datacamp[,c("Adgroup","Impr","Clicks")])
do_cero_df<-do_df[do_df$Impr==0,]
do_notcero_df<-do_df[do_df$Impr>0,]

merged<-merge(as.data.frame(table(datacamp$Adgroup)), 
              as.data.frame(table(do_cero_df$Adgroup)), all=TRUE,by = "Var1")
merged<-merge(merged, as.data.frame(table(do_notcero_df$Adgroup)),all = TRUE, by="Var1")

camps<-data.frame(varsvo,merged[,-1])
colnames(camps)<-c("camp", "count", "zero_impr", "notcero_impr")
camps<-camps[order(camps$count),]
camps[is.na(camps)]<-0
kable(camps)
```

Para validar podemos ver que la campaña "Blanket English" no produjo ninguna impresión en ninguna de sus campañas. Vamos a ver cuantas impresiones se produjeron en cada campaña.

```{r}
data_original$Impr[data_original$Adgroup=="Blanket English"]
```

Podemos corroborar que ninguna produjo impresiones. Por otra parte podemos ver cuanto fue el `MaxCPC` en las campañas que no produjeron impresiones:

- `Blanket English`

```{r}
summary(data_original$MaxCPC[data_original$Adgroup=="Blanket English"])
```

- `Shawl English`
```{r}
summary(data_original$MaxCPC[data_original$Adgroup=="Shawl English"])
```

- `Sock English`
```{r}
summary(data_original$MaxCPC[data_original$Adgroup=="Sock English"])
```

Podemos ver que los números son similares, pero si lo comparamos con la campaña `Poncho English` que tiene $201$ campañas con impresiones podemos observar grandes diferencias:

- `Poncho English`
```{r}
summary(data_original$MaxCPC[data_original$Adgroup=="Poncho English"])
```


### Distribución de cada variable

#### Variable `MaxCPC`

Esta variable es continua y positiva, sus principales características las podemos ver con el siguiente comando:

```{r}
summary(data$MaxCPC)
```

```{r,echo=FALSE}
par(mfrow=c(2,2))
plot(data$MaxCPC)
boxplot(data$MaxCPC)
hist(data$MaxCPC, breaks=25)
plot(density(data$MaxCPC))
```
 
Comparando distintas funciones de densidad, concluimos que la función que mejor se aproxima a estos datos es una Gamma con parámetros $\alpha=1.55447879$ y $\beta=4.43680739$. Este resultado esta sustentado con la siguiente prueba

```{r}
wilcox.test(data$MaxCPC,paired = FALSE, 
            rgamma(length(data$MaxCPC),shape=1.55447879,rate=4.43680739) )
```

Esta prueba contrasta la hipótesis nula que los datos se distribuyen como una Gamma contra que no, como el p-valor es mayor que 0.05, rechazamos la hipótesis nula, concluyendo que existe suficiente evidencia estadística para decir que la variable `MaxCPC` se distribuye como una Gamma.

Si a esta variable le sacamos los datos Outliers llegamos a que los datos corresponde a una distribución Weibull (Revisar documento outlier variable MaxCPC).

#### Variable `Clicks`

```{r}
summary(data$Clicks)
```

```{r}
par(mfrow=c(2,2))
plot(data$Clicks)
boxplot(data$Clicks)
hist(data$Clicks, breaks=25)
plot(density(data$Clicks))
```

#### Variable `Impr`

```{r}
summary(data$Impr)
```

```{r}
par(mfrow=c(2,2))
plot(data$Impr)
boxplot(data$Impr)
hist(data$Impr, breaks=25)
plot(density(data$Impr))
```

#### Variable `CTR`

```{r}
summary(data$CTR)
```

```{r}
par(mfrow=c(2,2))
plot(data$CTR)
boxplot(data$CTR)
hist(data$CTR, breaks=25)
plot(density(data$CTR))
```

#### Variable `AvgCPC`

```{r}
summary(data$AvgCPC)
```

```{r}
par(mfrow=c(2,2))
plot(data$AvgCPC)
boxplot(data$AvgCPC)
hist(data$AvgCPC, breaks=25)
plot(density(data$AvgCPC))
```

#### Variable `Costo`

```{r}
summary(data$Costo)
```

```{r}
par(mfrow=c(2,2))
plot(data$Costo)
boxplot(data$Costo)
hist(data$Costo, breaks=25)
plot(density(data$Costo))
```

#### Variable `AvgPos`

```{r}
summary(data$AvgPos)
```

```{r}
par(mfrow=c(2,2))
plot(data$AvgPos)
boxplot(data$AvgPos)
hist(data$AvgPos, breaks=25)
plot(density(data$AvgPos))
```

#### Variable `Qscore`

```{r}
summary(data$Qscore)
```

```{r}
par(mfrow=c(2,2))
plot(data$Qscore)
boxplot(data$Qscore)
hist(data$Qscore, breaks=25)
plot(density(data$Qscore))
```

#### Variable `Ventas`

```{r}
summary(data$Ventas)
```

```{r}
par(mfrow=c(2,2))
plot(data$Ventas)
boxplot(data$Ventas)
hist(data$Ventas, breaks=25)
plot(density(data$Ventas))
```

#### Variable `Costc`

```{r}
summary(data$Costc)
```

```{r}
par(mfrow=c(2,2))
plot(data$Costc)
boxplot(data$Costc)
hist(data$Costc, breaks=25)
plot(density(data$Costc))
```

#### Variable `Convr`

```{r}
summary(data$Convr)
```

```{r}
par(mfrow=c(2,2))
plot(data$Convr)
boxplot(data$Convr)
hist(data$Convr, breaks=25)
plot(density(data$Convr))
```

## ¿Qué dependencias hay entre las variables?

TODO: Análisis de correlación

### Matríz de correlación

Vamos a dibujar la matrix de correlación entre las distintas variables.

```{r}
M<-as.matrix(data[,-1])
CorrM<-round(cor(M),digits = 2)
kable(CorrM)
```

-----

Hay una manera más visual de mostrar las correlaciones mediante el comando [`corrplot`](http://www.sthda.com/english/wiki/visualize-correlation-matrix-using-correlogram). De esta manera es más evidente cuales variables mantienen una correlación alta.

```{r}
corrplot(CorrM, type="lower", diag = FALSE, method = "circle")
```

Podemos notar que las correlaciones relevantes son las siguientes:

| Par de variables    | $\rho=R$         |
|---------------------|------------------|
| `MaxCPC` y `AvgCPC` | `r CorrM[5,1]`   |
| `Clicks` e `Impr`   | `r CorrM[2,3]`   |
| `Clicks` y `Costo`  | `r CorrM[2,6]`   |
| `Clicks` y `Ventas` | `r CorrM[2,9]`   |
| `Clicks` y `Costc`  | `r CorrM[2,10]`  |
| `Impr` y `Costo`    | `r CorrM[3,6]`   |
| `Impr` y `Costc`    | `r CorrM[3,10]`  |
| `Impr` y `Ventas`   | `r CorrM[3,9]`   |
| `Costo` y `Ventas`  | `r CorrM[6,9]`   |
| `Costo` y `Costc`   | `r CorrM[6,10]`  |
| `Ventas` y `Costc`  | `r CorrM[9,10]`  |
| `Ventas` y `Convr`  | `r CorrM[9,11]`  |

Por otra parte podemos hacer una prueba de correlación con el comando `cor.test` y dejar en blanco las correlaciones no significativas.

```{r}
cor.mtest <- function(mat, ...) {
    mat <- as.matrix(mat)
    n <- ncol(mat)
    p.mat<- matrix(NA, n, n)
    diag(p.mat) <- 0
    for (i in 1:(n - 1)) {
        for (j in (i + 1):n) {
            tmp <- cor.test(mat[, i], mat[, j], ...)
            p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
        }
    }
  colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
  p.mat
}
p.mat<-cor.mtest(M)
```

Ahora vamos a dibujar el mismo gráfico pero dejando las correlaciones no significativas en blanco:

```{r}
corrplot(CorrM, type="lower", diag = FALSE, method = "circle", 
         p.mat = p.mat, sig.level = 0.01, insig = "blank")
```


TODO: Dar una explicación de los resultados sobre las correlaciones más importantes

### Relación entre las variables dos a dos

Vamos ahora a dibujar las variables y sus relaciones dos a dos

TODO: Dibujar sólo las que aparecen en la tabla de correlación que son las más relevantes.

```{r}
plot(data[-1])
```


#### Relación entre `Costos` y `Ventas`

```{r}
mcostventas<-as.data.frame(cbind(data$Costo, data$Ventas))

colnames(mcostventas)<-c("Costo", "Ventas")
#mcostventas

mcvordered<-mcostventas[order(mcostventas$Costo),]

plot(mcvordered, type="l",
     xlab="Costos", ylab="Ventas", main="Costos vs. Ventas")
```


#### Relación entre `Costo` y `Ventas` (`Ventas` > 0)

```{r}
plot(data$Costo[data$Ventas>0],data$Ventas[data$Ventas>0], 
     xlab="Costos", ylab="Ventas", main="Costos vs. Ventas (Ventas > 0)",
     type="p", pch=20)
#c(data$Costo[data$Ventas>0],data$Ventas[data$Ventas>0])
#c(data$Costo,data$Ventas)
```



#### Relación entre `Impr` (Impresiones) y `Clicks`

Esta es una relación muy importante, ya que todo el modelo depende de las Impresiones (`Impr`) y es de interés conocer como evolucionan los `Click` dadas las impresiones.

En primer lugar vamos a dibujar un gráfico que muestre la relación entre los puntos, para luego dibujar un modelo de regresión lineal simple entre ambas variables.

TODO: Eliminar más outliers
TODO: Ver que se puede hacer con los datos pequeños (buscar sólo datos relevantes)

```{r}
mic<-as.data.frame(cbind(data$Adgroup,data$Impr, data$Clicks))
colnames(mic)<-c("Adgroup", "Impr", "Clicks")
mic$Impr = as.numeric(as.character(mic$Impr))
mic$Clicks = as.numeric(as.character(mic$Clicks))
micordered<-mic[order(mic$Impr),]

par(mfrow=c(1,2))
plot(micordered$Impr, micordered$Clicks,
     xlab="Impresiones", ylab="Clicks", main="Impr vs. Clicks",
     type="p", pch=20)

plot(micordered$Impr, micordered$Clicks,
     xlab="Impresiones", ylab="Clicks", main="Impr vs. Clicks",
     type="p", pch=20, col="gray")
linear.model.mic<-lm(Clicks ~ Impr,data = micordered)
micordered.R.sqr<-round(summary(linear.model.mic)$adj.r.square, digits = 2)
abline(linear.model.mic, col="black")
text(10000, 850, paste("R^2=", micordered.R.sqr), cex = .8)
par(mfrow=c(2,2))
plot(linear.model.mic)
par(mfrow=c(1,1))
```

En este caso podemos apreciar que el `r (micordered.R.sqr*100)`% de la variabilidad de `Clicks` es explicada por `Impr`. Esto corrobora que la relación lineal entre ambas es `r round(sqrt(micordered.R.sqr), digits=2)`.

TODO: Verificar las premisas del modelo lineal



```{r}
micordered[micordered$Impr>40000,]
```

```{r}
par(mfrow=c(1,2))
new.micordered<-micordered[micordered$Impr!=52732,]
plot(new.micordered$Impr, new.micordered$Clicks,
     xlab="Impresiones", ylab="Clicks", main="Impr vs. Clicks",
     type="p", pch=20, col="gray")
linear.model.mic<-lm(Clicks ~ Impr, data = new.micordered)
micordered.R.sqr<-round(summary(linear.model.mic)$adj.r.square, digits = 2)
abline(linear.model.mic, col="black")
text(13000, 850, paste("R^2=", micordered.R.sqr), cex = .8)

new.micordered<-new.micordered[new.micordered$Impr!=83438,]
plot(new.micordered$Impr, new.micordered$Clicks,
     xlab="Impresiones", ylab="Clicks", main="Impr vs. Clicks",
     type="p", pch=20, col="gray")
linear.model.mic<-lm(Clicks ~ Impr, data = new.micordered)
micordered.R.sqr<-round(summary(linear.model.mic)$adj.r.square, digits = 2)
abline(linear.model.mic, col="black")
text(5000, 400, paste("R^2=", micordered.R.sqr), cex = .8)
par(mfrow=c(1,1))
```


#### Relación entre `Qscore` y `Ventas`

```{r}
mqv<-as.data.frame(cbind(data$Adgroup, data$Qscore, data$Ventas, data$MaxCPC))
colnames(mqv)<-c("Adgroup", "Qscore", "Ventas", "MaxCPC")
mqv$Qscore = as.numeric(as.character(mqv$Qscore))
mqv$Ventas = as.numeric(as.character(mqv$Ventas))
mqv$MaxCPC = as.numeric(as.character(mqv$MaxCPC))

lm.out.mqv<-lm(Ventas ~ MaxCPC + Qscore, data = mqv)
summary(lm.out.mqv)
```




```{r}
mqv<-as.data.frame(cbind(data$Qscore, data$Ventas))
colnames(mqv)<-c("Qscore", "Ventas")
mqvordered<-mqv[order(mqv$Qscore),]

plot(mqvordered, 
     xlab="Qscore", ylab="Ventas", main="Qscore vs. Ventas",
     type="p", pch=20)
```






```{r}
mqv<-as.data.frame(cbind(data$Adgroup,data$Qscore, data$Ventas))
colnames(mqv)<-c("Adgroup", "Qscore", "Ventas")
mqv$Qscore = as.numeric(as.character(mqv$Qscore))
mqv$Ventas = as.numeric(as.character(mqv$Ventas))
mqvordered<-mqv[order(mqv$Qscore),]

par(mfrow=c(1,2))
plot(mqvordered$Qscore, mqvordered$Ventas,
     xlab="Qscore", ylab="Ventas", main="Qscore vs. Ventas",
     type="p", pch=20)

plot(mqvordered$Qscore, mqvordered$Ventas,
     xlab="Qscore", ylab="Ventas", main="Qscore vs. Ventas",
     type="p", pch=20, col="gray")
linear.model.mqv<-lm(Ventas ~ Qscore, data = mqvordered)
mqvordered.R.sqr<-round(summary(linear.model.mqv)$adj.r.square, digits = 2)
abline(linear.model.mqv, col="black")
text(1, 12, paste("R^2=", mqvordered.R.sqr), cex = .8)
par(mfrow=c(1,1))
```



TODO: Revisar cómo manejar los datos para expresar mejor la relación.

```{r}
qs<-c()
sales<-c()
for (i in 1:(length(mqv$Qscore))) {
  if (mqv[i,]$Ventas>0) {
    qs<-c(qs,rep(mqv[i,]$Qscore, times=mqv[i,]$Ventas))
    sales<-c(sales,rep(1, times=mqv[i,]$Ventas))
  } else {
    qs<-c(qs, mqv[i,]$Qscore)
    sales<-c(sales, 0)
  }
}

mqvlog<-data.frame(qs,sales)

mod.sales<-glm(sales ~ qs, data=mqvlog, family = "binomial")

plot(mqvlog, 
     main = "Qscore vs. Ventas", xlab = "Qscore",
     ylab = "Ventas", 
     col=ifelse(mqvlog$sales==1,"red","blue"))

beta0<-mod.sales$coefficients[1]
beta1<-mod.sales$coefficients[2]

x<-sort(mqvlog$qs) 
pi<-exp(beta0+beta1*x)
y<-1/(1+(1/pi))
plot(x, y, type = "l", col= "blue", main = TeX('Qscore vs Estimador de pi'), 
    xlab="Qscore", ylab = TeX('Estimador de pi'))
```


#### Relación entre `Qscore` y `AvgPos`

```{r}
mqap<-as.data.frame(cbind(data$Qscore, data$AvgPos))

colnames(mqap)<-c("Qscore", "AvgPos")
#mqap

mqapordered<-mqap[order(mqap$Qscore),]

plot(mqapordered, type="l")
```


#### Relación entre `AvgPos` y `Ventas`

```{r}
mapv<-as.data.frame(cbind(data$AvgPos, data$Ventas))

colnames(mapv)<-c("AvgPos", "Ventas")
#mapv

mapvordered<-mapv[order(mapv$AvgPos),]

plot(mapvordered, type="l")
```

#### Relación entre `Qscore` y `Impr`

```{r}
mqi<-as.data.frame(cbind(data$Qscore, data$Impr))

colnames(mqi)<-c("Qscore", "Impr")
#mqi

mqiordered<-mqi[order(mqi$Qscore),]

plot(mqiordered, type="l")
```

#### Relación entre `Click` y `Costo`

```{r}
mcc<-as.data.frame(cbind(data$Clicks, data$Costo))

colnames(mcc)<-c("Clicks", "Costo")
#mcc

mccordered<-mcc[order(mcc$Clicks),]

plot(mccordered, type="l")
```


#### Relación entre `AvgPos` y `Clicks`

```{r}
mapc<-as.data.frame(cbind(data$AvgPos, data$Clicks))

colnames(mapc)<-c("AvgPos", "Clicks")
#mapc

mapcordered<-mapc[order(mapc$AvgPos),]

plot(mapcordered, type="l")
```


#### Relación entre `MaxCPC` y `AvgPos`

```{r}
mmcap<-as.data.frame(cbind(data$MaxCPC, data$AvgPos))

colnames(mmcap)<-c("MaxCPC", "AvgPos")
#mmcap

mmcapordered<-mmcap[order(mmcap$MaxCPC),]

plot(mmcapordered, type="l")
```

#### Relación entre `MaxCPC` y `Impr`

```{r}
mmi<-as.data.frame(cbind(data$MaxCPC[data$MaxCPC<1], data$Impr[data$MaxCPC<1]))

colnames(mmi)<-c("MaxCPC", "Impr")
#mmi

mmiordered<-mmi[order(mmi$MaxCPC),]

plot(mmiordered, type="p")
```

#### Relación entre `Costo`, `Ventas` y `Costc`

```{r}
par(mfrow=c(1,2))
plot(data$Costo[data$Costc>0],data$Costc[data$Costc>0])
plot(data$Ventas[data$Costc>0],data$Costc[data$Costc>0])
par(mfrow=c(1,1))
```

## ¿Hay alguna relación entre el `MaxCPC`, `QScore` y el número de impresiones?

TODO: ¿Aplica algún modelo lineal para generar las impresiones dependiendo de lo que está dispuesto a pagar el anunciante y la calificación que recibe el anuncio?

```{r}
mod.impr<-lm(Impr ~ MaxCPC + Qscore, data = data)
summary(mod.impr)
```

```{r echo=FALSE}
par(mfrow=c(2,2))
plot(mod.impr)
par(mfrow=c(1,1))
```

```{r}
reduced_data<-data[-c(299,432,602),]
mod.impr2<-lm(Impr ~ MaxCPC + Qscore, data = reduced_data)
summary(mod.impr2)
par(mfrow=c(2,2))
plot(mod.impr2)
par(mfrow=c(1,1))
```

```{r}
#reduced_data<-data[-c(299,432,602),]
mod.impr3<-glm(Impr ~ MaxCPC + Qscore, data = reduced_data, family = "Gamma")
summary(mod.impr3)
par(mfrow=c(2,2))
plot(mod.impr3)
par(mfrow=c(1,1))
```

## ¿Hay alguna relación entre la campaña en sí mismo, las palabras clave y las impresiones?

TODO Daysi: ¿Cómo podemos clasificar las campañas en base a sus palabras claves, cuales generan más impresiones y más palabras claves?

##  ¿Qué importancia tienen las impresiones en el modelo?

### Análisis de Componentes Principales

TODO Daysi: Mejorar el análisis.

```{r}
acp<-prcomp(M)
summary(acp)
#Desviación estandar de cada componente
acp$sdev
#La media de cada variable
acp$center
#Los coeficientes de los componentes
data.frame(acp$rotation[,1],acp$rotation[,2])
```

Al aplicar el Análisis de Componentes Pricipales a los datos donde la cantidad de impresiones es mayor que $0$, sólo tomamos en cuenta los dos primeros componentes, ya que la suma de varianza acumulada con estos dos componentes es $100\%$, el primer componente le da más peso a Impresiones, Costo y Clicks, aunque para estas dos últimas variables no tienen mucho peso; para el segundo componente principal las variables con mayor peso son Clicks, Qscore, Ventas, Costoc y Costo.

## ¿Cuales campañas son más eficientes si se minimiza el costo y si se maximizan las ventas?

Vamos a hacer un modelo lineal para explicar la variable `Costoc` en base al resto de las variables del modelo.

```{r}
mod.costoc<-lm(Costc ~ MaxCPC+Clicks+Impr+CTR+AvgCPC+AvgPos+Qscore+Ventas+Costo+Convr, 
               data=data)
summary(mod.costoc)
```

Podemos notar que el coeficiente de determinación múltiple $R^2=$ `r round(summary(mod.costoc)$r.squared,digits=2)`.


```{r}
mod.costo<-lm(Costo ~ MaxCPC+Clicks+Impr+CTR+AvgCPC+AvgPos+Qscore+Ventas+Costc+Convr, 
              data=data)
summary(mod.costo)
```

```{r}
anova(mod.costo)
```

```{r}
mod.costo.red<-lm(Costo ~ MaxCPC+Clicks+Impr+CTR+AvgCPC+Costc, data=data)
summary(mod.costo.red)
```
```{r}
anova(mod.costo.red)
```

TODO: Hacer un modelo lineal u otro para ajustar las ventas

```{r}
mod.ventas<-lm(Ventas ~ MaxCPC+Clicks+Impr+CTR+AvgCPC+Costo+AvgPos+Qscore+Costc+Convr, 
               data=data)
summary(mod.ventas)
```
```{r}
anova(mod.ventas)
```

```{r}
mod.ventas.red<-lm(Ventas ~ MaxCPC+Clicks+Impr+CTR+AvgPos+Costc+Convr, data=data)
summary(mod.ventas.red)
```

```{r}
anova(mod.ventas.red)
```


```{r echo=FALSE, results='asis'}
cat("\n\n\\pagebreak\n")
```

### Resumen por campaña


- Ordenado por `Clicks`

```{r, echo=FALSE, results='asis'}
for(i in 1:(length(varsv))) {
  data$Adgroup[data$Adgroup==varsv[i]]<-i
}
data$Adgroup<-as.numeric(data$Adgroup)
sum_cli<-c()
sum_imp<-c()
sum_ven<-c()
sum_cos<-c()
pro_max<-c()
ctr<-c()
avgc<-c()
pro_avgp<-c()
pro_Qsc<-c()
cstc<-c()
conr<-c()

for (i in 1:(length(varsv))){
  df<-as.data.frame(data[data$Adgroup==i,])
  sum_cli<-c(sum_cli,sum(df$Clicks))
  sum_imp<-c(sum_imp,sum(df$Impr))
  sum_ven<-c(sum_ven,sum(df$Ventas))
  sum_cos<-c(sum_cos,sum(df$Costo))
  pro_max<-c(pro_max,mean(df$MaxCPC))
  ctr<-c(ctr,sum(df$Clicks)/sum(df$Impr))
  avgc<-c(avgc,sum(df$Costo)/sum(df$Clicks))
  pro_avgp<-c(pro_avgp,mean(df$AvgPos))
  pro_Qsc<-c(pro_Qsc,mean(df$Qscore))
  cstc<-c(cstc,sum(df$Costo)/sum(df$Ventas))
  conr<-c(conr,sum(df$Ventas)/sum(df$Clicks))
}

removeWords <- function(str, stopwords) {
  x <- unlist(strsplit(str, " "))
  paste(x[!x %in% stopwords], collapse = " ")
}

for (i in 1:(length(varsv))) {
  varsv[i]<-substr(removeWords(varsv[i],"English"), 1, 13)
}

df_final<-data.frame("Camp"= varsv, "Clicks"=sum_cli,
                     "Impr"=sum_imp, "Vent"=sum_ven,
                     "Costos"=sum_cos,"AMaxC"=pro_max,
                     "CTR"=ctr,"ACPC"=avgc,"APos"=pro_avgp,
                     "AQsc"=pro_Qsc,"Costc"=cstc,"Conr"=conr)

kable(df_final[order(df_final$Clicks),], digits = 2, row.names = FALSE)
cat("\n\n\\pagebreak\n")
```

- Ordenado por `Impr`
 
```{r, echo=FALSE, results='asis'}
kable(df_final[order(df_final$Impr),], digits = 2, row.names = FALSE)
cat("\n\n\\pagebreak\n")
```
 
- Ordenado por `Ventas`
 
```{r, echo=FALSE, results='asis'}
kable(df_final[order(df_final$Vent),], digits = 2, row.names = FALSE)
cat("\n\n\\pagebreak\n")
```

- Ordenado por `Costos`

```{r, echo=FALSE, results='asis'}
kable(df_final[order(df_final$Costos),], digits = 2, row.names = FALSE)
cat("\n\n\\pagebreak\n")
```

- Ordenado por `Costc`

```{r, echo=FALSE, results='asis'}
kable(df_final[order(df_final$Costc),], digits = 2, row.names = FALSE)
cat("\n\n\\pagebreak\n")
```

## Links para revisar

- [Predictive Models to Optimize Adwords](https://staesthetic.wordpress.com/2015/09/27/3-predictive-model-to-optimize-adwords/)
- [Adwords Budget Optimization](http://www.marketingdistillery.com/2014/09/11/adwords-budget-optimization-for-long-tail-keywords/)
- [Linear, Logistic and Poisson Regression](http://www.marketingdistillery.com/2014/11/23/linear-regression-vs-logistic-regression-vs-poisson-regression/)
- [Intro to GLM](https://onlinecourses.science.psu.edu/stat504/node/216)
- [Stanford Computational Advertising](https://web.stanford.edu/class/msande239/)
- [Princeton GLM](http://data.princeton.edu/R/glms.html)
- [Statmethods GLM](http://www.statmethods.net/advstats/glm.html)
- [Logistic and Maxentropy](http://www.win-vector.com/blog/2011/09/the-equivalence-of-logistic-regression-and-maximum-entropy-models/)

[^1]: [Definición y uso de QScore](https://support.google.com/adwords/answer/7050591)
[^2]: [Glosario de Adwords](https://support.google.com/adwords/topic/3121777?hl=en&ref_topic=3119071)
